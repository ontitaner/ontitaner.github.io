---
layout : post
title : "C的内存的动态分配与释放相关总结"
category : C
duoshuo: true
date : 2015-03-02
tags : [C ]
SyntaxHihglighter: true
shTheme: shThemeMidnight # shThemeDefault  shThemeDjango  shThemeEclipse  shThemeEmacs  shThemeFadeToGrey  shThemeMidnight  shThemeRDark
---

本篇是关于C的内存的动态分配与释放相关总结

<!-- more -->

什么是局部变量、全局变量和静态变量？

顾名思义，局部变量就是在一个有限的范围内的变量，作用域是有限的，对于程序来说，在一个函数体内部声明的普通变量都是局部变量，局部变量会在栈上申请空间，函数结束后，申请的空间会自动释放。而全局变量是在函数体外申请的，会被存放在全局（静态区）上，知道程序结束后才会被结束，这样它的作用域就是整个程序。静态变量和全局变量的存储方式相同，在函数体内声明为static就可以使此变量像全局变量一样使用，不用担心函数结束而被释放。

**malloc原理**

malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。调用free函数时，它将用户释放的内存块连接到空闲链上。

到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。

分类：

* 栈区（stack）—由编译器自动分配释放，存放**函数的参数值，局部变量的值**等。其操作方式类似于数据结构中的栈

* 堆区（heap）—一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表

* 全局区（静态区）（static）—**全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放**

* 常量区—**常量字符串就是放在这里的，直到程序结束后由系统释放**

* 代码区—存放函数体的二进制代码

<pre class="brush: c; ">
//main.cpp    
int a = 0; //全局初始化区
char *p1; //全局未初始化区
    
main()
{
    int b; //栈
    char s[] = "abc"; //栈
    char *p2; //栈
    char *p3 = "123456"; //123456\\0在常量区，p3在栈上。
    static int c =0;//全局（静态）初始化区
    p1 = (char *)malloc(10);    
    p2 = (char *)malloc(20);//分配得来得10和20字节的区域就在堆区。
    strcpy(p1, "123456"); //123456\\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。        
}
</pre>

---

1. **静态数组与动态数组**

	静态数组比较常见，数组长度预先定义好，在整个程序中，一旦给定大小后就无法再改变长度，静态数组自己自动负责释放占用的内存。
	
	动态数组长度可以随程序的需要而重新指定大小。动态数组由内存分配函数(malloc)从堆（heap）上分配存储空间，只有当程序执行了分配函数后，才为其分配内存，同时由程序员自己负责释放分配的内存（free）。
	
1. **为什么要使用动态数组?**

	在实际的编程中，往往会发生这种情况，即所需的内存空间取决于实际输入的数据，而无法预先确定。对于这种问题，用静态数组的办法很难解决。为了解决上述问题，c语言提供了一些内存管理函数，这些内存管理函数结合指针可以按需要动态地分配内存空间，来构建动态数组，也可把不再使用的空间回收待用，为有效地利用内存资源提供了手段。
	
1. **动态数组与静态数组的比较**

	对于静态数组，其创建非常方便，使用完也无需释放，要引用也简单，但是创建后无法改变其大小是其致命弱点！ 
	
	对于动态数组，其创建麻烦，使用完必须由程序员自己释放，否则严重会引起内存泄露。但其使用非常灵活，能根据程序需要动态分配大小。
	
1. **如何构建动态数组？**

	构建动态数组时，我们遵循下面的原则：**申请的时候从外层往里层，逐层申请；释放的时候从里层往外层，逐层释放；**

1. **动态内存分配与释放函数**

	<pre class="brush: c; ">
	void *malloc(unsigned int size);
	void *calloc(unsigned int num, unsigned int size); 
	void *realloc(void *p,unsigned int size); 
	void free(void *p);
	</pre>

	相关说明：
	
	* **函数说明**
	
		malloc()函数成功：返回所开辟空间首地址；失败:返回空指针；功能：向系统申请size字节堆的空间；
		
		calloc()成功：返回所开辟空间首地址；失败:返回空指针；功能：按类型向系统申请num个size字节堆的空间；
		
		realloc()成功：返回所开辟空间首地址；失败:返回空指针；功能：将p指向的空间变为个size字节堆的空间；
		
		free()没有返回值，释放p指向的堆空间；
		
	* **规定为void *类型，这并不是说该函数调用后无返回值，而是返回一个结点的地址，该地址的类型为void(无类型或类型不确定）,即一段存储区的首址，其具体类型无法确定，只有使用时根据各个域值数据再确定。可以用强制转换的方法将其转换为别的类型。例如：**
	
		<pre class="brush: c; ">
		double *pd = NULL;
		pd = (double *)calloc(10, sizeof(double));
		</pre>
		
		表示将向系统申请10个连续的double类型的存储空间，并用指针pd指向这个连续的空间的首地址。并且用(double)对calloc()的返回类型进行转换，以便把double类型数据的地址赋值给指针pd。
		
	* **使用sizeof的目的是用来计算一种类型的占有的字节数，以便适合不同的编译器。**
	
	* **检查动态内存是否分配成功**
	
		由于动态分配不一定成功，为此要附加一段异常处理程序，不致程序运行停止，使用户不知所措。通常采用这样的异常处理程序段：
		
		<pre class="brush: c; ">
		if (p == NULL) /* 或者if（!p）*/ 
		{ 
		    printf("动态申请内存失败！\n");
		    exit(1); //异常退出 
		}
		</pre>
		
	* **这四个函数头文件均包含在中**
	
	* **分配的堆空间是没有名字的,只能通过返回的指针找到它**
	
	* **绝不能对非动态分配存储块使用free。也不能对同一块内存区同时用free释放两次**
	
	* **调用free()时,传入指针指向的内存被释放,但调用函数的指针值可能保持不变, 因为p是作为形参而传递给了函数。严格的讲, 被释放的指针值是无效的, 因为它已不再指向所申请的内存区。这时对它的任何使用便可能会可带来问题。所以在释放一个指针指向的内存后，将该指针赋值为0，避免该指针成为野指针：**
	
		<pre class="brush: c; ">
		int *p = (int *)malloc(sizeof(int));
		free(p); /*释放p指向内存*/
		p = 0; /*或者 p = NULL，释放p指向的内存后，将p指针赋值为0，避免p指针成为野指针*/
		</pre>
	
	* **malloc与calloc的区别，对于用malloc分配的内存区间，如果原来没有被使用过，则其中的每一位可能都是0；反之，如果这部分内存空间曾经被分配、释放和重新分配，则其中可能遗留各种各样的数据。也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常运行，但经过一段时间后(内存空间已被重新分配)可能会出现问题，因此在使用它之前必须先进行初始化（可用memset函数对其初始化为0），但调用calloc()函数分配到的空间在分配时就已经被初始化为0了。当你在calloc()函数和malloc()函数之间作选择时，你需考虑是否要初始化所分配的内存空间，从而来选择相应的函数。**
	
1. **动态数组构建过程**

	以三维整型数组为例int array[x][y][z]
	
	先遵循从外到里，逐层申请的原则:
	
	最外层的指针就是数组名array，他是一个三维指针，指向的是array[]，array[]是二维指针，所以给array申请内存空间需要一个三维指针int *** p;
	
	<pre class="brush: c; ">
	/*给三维数组array[x][y][z]动态分配内存*/
	int *** p = (int ***)malloc(x * sizeof(int **)); 
	/*或者如下*/
	array = (int ***)malloc(x * sizeof(int **))
	/*指针p指向的是array三维数组的第一维，有x个元素，所以要sizeof(x * (int **))*/
	</pre>
	
	次层指针是array[]，它是一个二维指针，指向的是array[][]，array[][]是一维指针：
	
	<pre class="brush: c; ">
	int i, j;
	for (i = 0; i < x; i++)
	{
	    array[i] = (int **)malloc(y * sizeof(int *));
	}
	</pre>
	
	最内层指针是array[][],它是个一维指针，所指向的是array[][][]，其是个整型常量。所以给array[][]申请内存应：
	
	<pre class="brush: c; ">
	int i, j;
	for (i = 0; i < x; i++)
	{
	    for (j = 0; j < y; j++)
	    {
	        array[i][j] = (int *)malloc(z * sizeof(int));
	    }
	}
	</pre>
	
	综合以上三步：
	
	<pre class="brush: c; ">
	/*动态构建三维数组内存分配函数*/
	/*
	 * pArr: 指向三维数组首地址
	 * x: 三维数组第一维元素个数
	 * y: 三维数组第二维元素个数
	 * z: 三维数组第三维元素个数
	 */
	void Create3DActiveArray(int ***pArr, int x, int y, int z)
	{
	    int i, j, k;
	    pArr = (int ***)malloc(x * sizeof(int **));
	
	    for (i = 0; i < x; i++)
	    {
	        pArr[i] = (int **)malloc(y * sizeof(int *));
	        for (j = 0; j < y; j++)
	        {
	           pArr[i][j] = (int *)malloc(z * sizeof(int));
	           for (k = 0; k < z; k++)
	           {
	              pArr[i][j][k] = i + j + k;
	           }
	        }
	    }
	}
	</pre>
	
	内存释放函数：
	
	<pre class="brush: c; ">
	void Free3DActiveArray(int ***pArr, int x, int y)
	{
	    int i, j, k;
	    for (i = 0; i < x; i++)
	    {
	        for (j = 0; j < y; j++)
	        {
	            free(pArr[i][j]);
	            pArr[i][j] = 0;
	        }
	        free(pArr[i]);
	        pArr[i] = 0;
	    }
	    free(pArr);
	    
	}
	</pre>